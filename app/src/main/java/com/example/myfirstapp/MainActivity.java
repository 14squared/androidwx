package com.example.myfirstapp;

import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.Manifest;
import android.content.pm.PackageManager;
import android.widget.TextView;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.view.View;

import org.json.*;


import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.toolbox.JsonObjectRequest;
import com.android.volley.toolbox.RequestFuture;
import com.android.volley.toolbox.Volley;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.OnSuccessListener;

import org.json.JSONObject;

import java.util.concurrent.ExecutionException;

public class MainActivity extends AppCompatActivity {
    public static final String EXTRA_MESSAGE = "com.example.myfirstapp.MESSAGE";
    public static String lat = null;
    public static String lon = null;
    public static String acc = null;
    public String newurl = null;
    public String name = null;
    public Boolean isDay = null;
    public String temperature = null;
    public String windSpeed = null;
    public String windDirection = null;
    public String presentConditions = null;

    private FusedLocationProviderClient fusedLocationClient;
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);
        setContentView(R.layout.activity_main);
        //TextView weatherBox;
        //weatherBox = (TextView) findViewById(R.id.longForecastView);
    }

    //called when the user taps the send button
    public void sendMessage(View view){
        //do something after the button gets tapped.
        Intent intent = new Intent(this, DisplayMessageActivity.class);
        startActivity(intent);
    }


    public void GetLocation(View view){

        setContentView(R.layout.activity_main);
        final TextView box = findViewById(R.id.longForecastView);


        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
                != PackageManager.PERMISSION_GRANTED) {
            // Permission is not granted

        }
        ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_COARSE_LOCATION}, 1);

        fusedLocationClient.getLastLocation()
                .addOnSuccessListener(this, new OnSuccessListener<Location>() {
                    @Override
                    public void onSuccess(Location location) {
                        // Got last known location. In some rare situations this can be null.
                        if (location != null) {
                            // Logic to handle location object
                            lat = Double.toString(location.getLatitude());
                            lon = Double.toString(location.getLongitude());
                            acc = Float.toString(location.getAccuracy());

                            };

                        }

                });
    }


    private String getForcastByLocation(String lat, String lon){
        // Create a temporary request queue; it will be destroyed when this function exists, but
        // that's okay because we'll block until each request is completed using RequestFuture.get()
        RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext());
        RequestFuture<JSONObject> future = RequestFuture.newFuture();
        String forecast = "";


        // Create request #1 (Get the points URL for a given Lat/Lon)
        String URL =("https://api.weather.gov/points/" + lat + "," + lon);
        JsonObjectRequest request = new JsonObjectRequest(Request.Method.GET, URL, new JSONObject(), future, future);
        requestQueue.add(request);
        try {
            // get() is a blocking call (meaning, it won't return until it finishes, or throws an exception)
            JSONObject obj = future.get();

            // Parse the JSON response to pull out the forecast detail
            URL = obj.getJSONObject("properties").getString("forecast");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (JSONException e) {
            e.printStackTrace();
        }

        // Create Request #2 to get the forecast from the URL generated by the previous request
        future = RequestFuture.newFuture();
        request = new JsonObjectRequest(Request.Method.GET, URL, new JSONObject(), future, future);
        requestQueue.add(request);
        try {
            // get() is a blocking call (meaning, it won't return until it finishes, or throws an exception)
            JSONObject obj = future.get();
            // Parse the JSON response to pull out the forecast details
            forecast = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("detailedForecast");
            name = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("name");
            temperature = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("temperature");
            windSpeed = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("windSpeed");
            windDirection = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("windDirection");
            isDay = Boolean.parseBoolean(obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("name"));
            presentConditions = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("shortForecast");

        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return forecast;
    }

    public void getWeather(View view) {

        setContentView(R.layout.activity_main);
        final TextView longForecastView = findViewById(R.id.longForecastView);
        final TextView conditionsView = findViewById(R.id.shortForecastView);
        final TextView nameView = findViewById(R.id.nameView);
        final TextView temperatureView = findViewById(R.id.tempView);


        // Define a temporary thread to handle the weather query in the background
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                // Test values for my dumb emulator
                //lat = "39.745";
                //lon = "-97.089";

                // Get the forecast and populate the text box within the thread
                String forecast = getForcastByLocation(lat, lon);
                longForecastView.setText(forecast);
                //nameView.setText(name);
                //temperatureView.setText(temperature);
                //conditionsView.setText(presentConditions);

            }
        });

        // Launch the thread
        thread.start();
    }
}
