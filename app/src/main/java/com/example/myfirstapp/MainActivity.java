package com.example.myfirstapp;

import androidx.annotation.ColorInt;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.Manifest;
import android.content.pm.PackageManager;
import android.graphics.Color;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.content.Intent;
import android.location.Location;
import android.os.Bundle;
import android.view.View;

import org.json.*;


import com.android.volley.Request;
import com.android.volley.RequestQueue;
import com.android.volley.toolbox.JsonObjectRequest;
import com.android.volley.toolbox.RequestFuture;
import com.android.volley.toolbox.Volley;
import com.google.android.gms.location.FusedLocationProviderClient;
import com.google.android.gms.location.LocationServices;
import com.google.android.gms.tasks.OnSuccessListener;

import org.json.JSONObject;
import org.w3c.dom.Text;

import java.util.concurrent.ExecutionException;

public class MainActivity extends AppCompatActivity {
    public static final String EXTRA_MESSAGE = "com.example.myfirstapp.MESSAGE";
    public static String lat = null;
    public static String lon = null;
    public static String acc = null;
    public String newurl = null;

    private FusedLocationProviderClient fusedLocationClient;

    public void GetLocation(){

        setContentView(R.layout.activity_main);

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
                != PackageManager.PERMISSION_GRANTED) {
            // Permission is not granted

        }
        ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.ACCESS_COARSE_LOCATION}, 1);

        fusedLocationClient.getLastLocation()
                .addOnSuccessListener(this, new OnSuccessListener<Location>() {
                    @Override
                    public void onSuccess(Location location) {
                        // Got last known location. In some rare situations this can be null.
                        if (location != null) {
                            // Logic to handle location object
                            lat = Double.toString(location.getLatitude());
                            lon = Double.toString(location.getLongitude());
                            acc = Float.toString(location.getAccuracy());

                        };

                    }

                });
    }



    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);
        setContentView(R.layout.activity_main);
        GetLocation();


    }




    private JSONObject getForcastByLocation(String lat, String lon){
        // Create a temporary request queue; it will be destroyed when this function exists, but
        // that's okay because we'll block until each request is completed using RequestFuture.get()
        RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext());
        RequestFuture<JSONObject> future = RequestFuture.newFuture();
        JSONObject wholeResponse = null;


        // Create request #1 (Get the points URL for a given Lat/Lon)
        String URL =("https://api.weather.gov/points/" + lat + "," + lon);
        JsonObjectRequest request = new JsonObjectRequest(Request.Method.GET, URL, new JSONObject(), future, future);
        requestQueue.add(request);
        try {
            // get() is a blocking call (meaning, it won't return until it finishes, or throws an exception)
            JSONObject obj = future.get();

            // Parse the JSON response to pull out the forecast detail
            URL = obj.getJSONObject("properties").getString("forecast");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        } catch (JSONException e) {
            e.printStackTrace();
        }

        // Create Request #2 to get the forecast from the URL generated by the previous request
        future = RequestFuture.newFuture();
        request = new JsonObjectRequest(Request.Method.GET, URL, new JSONObject(), future, future);
        requestQueue.add(request);
        try {
            // get() is a blocking call (meaning, it won't return until it finishes, or throws an exception)
            JSONObject obj = future.get();
            // Parse the JSON response to pull out the forecast details
            wholeResponse = obj;

        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        return wholeResponse;
    }

    private String getLongForecast(JSONObject obj){
        String longForecast = "Error";
        try {
            longForecast = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("detailedForecast");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return longForecast;
    }

    private String getConditions(JSONObject obj){
        String conditions = "Error";
        try {
            conditions = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("shortForecast");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return conditions;
    }

    private String getTemp(JSONObject obj){
        String temperature = "Error";
        try {
            temperature = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("temperature");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return temperature;
    }


    private String getWind(JSONObject obj){
        String wind = "Error";
        String windDir = "Error";
        try {
            wind = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("windSpeed");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        try {
            windDir = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(0).getString("windDirection");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return windDir + " at " + wind;
    }

    private String getNextPeriodTitle(JSONObject obj){
        String title = "Error";
        try {
            title = obj.getJSONObject("properties").getJSONArray("periods").getJSONObject(1).getString("name");
        } catch (JSONException e) {
            e.printStackTrace();
        }
        return title;
    }

    public void getWeather(View view) {
        // Define a temporary thread to handle the weather query in the background
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                final TextView shortForecastView = findViewById(R.id.shortForecastView);
                final TextView tempView = findViewById(R.id.tempView);
                final TextView windView = findViewById(R.id.windConditions);

                // Test values for my dumb emulator
                //lat = "39.745";
                //lon = "-97.089";

                // Get the forecast and populate the text box within the thread
                JSONObject forecast = getForcastByLocation(lat, lon);
                String shortForecast = getConditions(forecast);
                String temp = getTemp(forecast);
                String windConditions = getWind(forecast);
                String nextTitle = getNextPeriodTitle(forecast);
                //longForecastView.setText(forecast.getJSONObject());
                shortForecastView.setText(shortForecast);
                tempView.setText(temp);
                windView.setText("Wind: " + windConditions);

            }
        });

        // Launch the thread
        thread.start();
    }

    public void testDrawTextView(View view) {
        //this would iterate through each available period in the returned weather data, adding a new line for each period. Ideally the formatting would look cleaner in the final version.
        for (Integer i = 0; i < 5; i++) {
            addWxPeriod(view, "Tonight", "84 - 60", "8 to 10 mph", "Cloudy");
        }
    }

    public void addWxPeriod(View view, String title, String temp, String wind, String shortForecast){
        LinearLayout layout = findViewById(R.id.newLayout);
        LinearLayout horizLayout = new LinearLayout(this);
        horizLayout.setOrientation(LinearLayout.HORIZONTAL);
        layout.addView(horizLayout);
        LinearLayout vertLayout = new LinearLayout(this);
        vertLayout.setOrientation(LinearLayout.VERTICAL);


        final TextView titleView = new TextView(this);
        titleView.setTextSize(24);
        titleView.setTextColor(Color.WHITE);
        titleView.setText(title);
        titleView.setPaddingRelative(16, 16, 16, 16);
        horizLayout.addView(titleView);

        horizLayout.addView(vertLayout);

        final TextView shortForecastView = new TextView(this);
        shortForecastView.setTextSize(16);
        shortForecastView.setTextColor(Color.WHITE);
        shortForecastView.setText(wind);
        shortForecastView.setPaddingRelative(16, 16, 16, 16);
        vertLayout.addView(shortForecastView);

        final TextView tempView = new TextView(this);
        tempView.setTextSize(16);
        tempView.setTextColor(Color.WHITE);
        tempView.setText(temp);
        tempView.setPaddingRelative(16, 16, 16, 16);
        vertLayout.addView(tempView);

        final TextView windView = new TextView(this);
        windView.setTextSize(16);
        windView.setTextColor(Color.WHITE);
        windView.setText(wind);
        windView.setPaddingRelative(16, 16, 16, 16);
        vertLayout.addView(windView);
    }
}
